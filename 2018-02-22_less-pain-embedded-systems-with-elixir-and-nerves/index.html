<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Less-Pain Embedded Systems with Elixir and Nerves</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css">
    <link rel="stylesheet" href="css/customizations.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <!-- Welcome -->

        <section>

          <section data-markdown class="title">
            <textarea data-template>
              # Less-Pain
              # Embedded Systems
              # with Elixir and Nerves

              ----

              LoneStar ElixirConf - 2018-02-22

              Greg Mefford (@ferggo)

              ![GregMefford](img/GregMefford.jpg) <!-- .element: class="plain" style="height: 4em" -->
              ![Le Tote](img/lt_logo.png) <!-- .element: class="plain" style="height: 4em" -->
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              # Code of Conduct ðŸ’œ

              http://lonestarelixir.com/2018/code-of-conduct
            </textarea>
          </section>

          <section data-markdown class="schedule">
            <textarea data-template>
              # Tentative schedule ðŸ•˜

              * 7:30 AM - 8:30 AM (1:00)
                * Registration/Breakfast
              * 8:30 AM - 10:00 AM (1:30)
                * Welcome / Overview
                * Quick Win
                * Nerves In Depth
              *  10:00 AM - 10:30 AM (0:30)
                * Break (and help resolve issues)
            </textarea>
          </section>

          <section data-markdown class="schedule">
            <textarea data-template>
              # Tentative schedule ðŸ•˜

              *  10:30 AM - 12:00 PM (1:30)
                * Scanning Barcodes
                * Custom Nerves Systems
                * Elixir Crash Course
              *  12:00 PM - 1:30 PM (1:30)
                * Lunch (and Play with `eye` firmware)
            </textarea>
          </section>

          <section data-markdown class="schedule">
            <textarea data-template>
              # Tentative schedule ðŸ•˜

              *  1:30 PM - 3:00 PM (1:30)
                * Logging / Monitoring
                * Robustness
                * Refactor and Re-Deploy
              *  3:00 PM - 3:30 PM (0:30)
                * Break
              *  3:30 PM - 5:00 PM (1:30)
                * Build / Lab time
            </textarea>
          </section>

        </section>

        <!-- Hardware Overview -->

        <section>

          <section data-background-image="img/hardware_overview.jpg" data-background-size="contain">
          </section>

          <section data-markdown>
            <textarea data-template>
              # For Today

              * Raspberry Pi Zero W + case
              * Pi camera v2
              * Zero-size camera ribbon cable
              * Lens adjustment tool
              * 16 GB class 10 MicroSD card
              * MicroSD card reader
              * Male USB to MicroUSB cable
              * QR codes and Stickers!
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              # For Later

              * MicroUSB OTG cable
              * HDMI to Mini HDMI cable
              * Standard-size camera ribbon cable
              * 5V 2.5A MicroUSB AC power adapter
              * 40-pin header
              * Heatsink
            </textarea>
          </section>

          <section data-background-image="img/hardware_assembly_01.jpg" data-background-size="contain">
          </section>

          <section data-background-image="img/hardware_assembly_02.jpg" data-background-size="contain">
          </section>

          <section data-background-image="img/hardware_assembly_03.jpg" data-background-size="contain">
          </section>

          <section data-background-image="img/hardware_assembly_04.jpg" data-background-size="contain">
          </section>

          <section data-background-image="img/hardware_assembly_05.jpg" data-background-size="contain">
          </section>

          <section data-background-image="img/hardware_assembly_06.jpg" data-background-size="contain">
          </section>

          <section data-background-image="img/hardware_assembly_07.jpg" data-background-size="contain">
          </section>

          <section data-background-image="img/hardware_assembly_08.jpg" data-background-size="contain">
          </section>

        </section>

        <!-- Elixir for Embedded -->

        <section>

          <section data-markdown>
            <textarea data-template>
              # Elixir ðŸ’œ Embedded
              Light-weight *concurrency*
              * Tons of tiny processes
              * Process-level fault-tolerance
              * Per-Process Garbage-Collection
              * Immutable Data Structures

              Notes:

              Due to its Erlang roots, Elixir was born to be embedded.

              Today's low-cost embedded platforms are yesterday's supercomputers,

              so it's unsurprising that the BEAM would work well there.

              But I want to talk for a minute about this one-two punch:

              Garbage-collection happens per-process, and data structures are immutable.
            </textarea>
          </section>

          <section data-background-image="img/gc_jvm.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              Here's what a typical memory usage graph looks like for

              a Java virtual machine under a constant workload.

              The shaded areas are wasted memory due mostly to a lack of

              immutable data structures, which prevents the garbage collector

              from quickly determining what memory is still in use somewhere.
            </aside>
          </section>

          <section data-background-image="img/gc_jvm_zoom.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              If we zoom in, we see the same process, but on a smaller scale.

              When the overall memory usage hits 75%, it triggers a Full-GC that

              stops the whole VM while it determines what memory is no longer

              referenced anywhere and frees it up.

              In a busy system, this can take a while and cause problems.
            </aside>
          </section>

          <section data-background-image="img/gc_beam.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              By contrast, the BEAM does garbage-collection on a per-process basis.

              There's very little waste for a system under constant load.

              The overall memory usage only ebbs and flows with the

              actual memory requirements of your workload.

              This means that you can run a system closer to its memory limit,

              provided that your workload doesn't have large peaks and valleys.

              That can be a very important property for an embedded system with

              only half a gig of RAM.
            </aside>
          </section>

          <section data-background-image="img/gc_beam_zoom.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              If we zoom in, we see that each process allocates some memory,

              does its work,

              with tiny, independent garbage-collections along the way,

              and frees it all when it's finished.

              At any moment, there are a bunch of processes allocating a

              small increment of memory, while a much smaller number are freeing

              their entire allocation.

              So the overall memory usage closely follows the actual demand on the system.
            </aside>
          </section>

          <section data-markdown>
            <textarea data-template>
              # Elixir ðŸ’œ Embedded
              *Binary* pattern-matching

              ``` elixir
              def decode(<<op::3, addr::6, data::7>>), do: {op, addr, data}

              # ...

              decode(<<0b01010101, 0b01010011>>) # => {2, 42, 83}
              ```

              Notes:

              Another thing that's really great about Elixir for embedded development

              is binary pattern-matching.

              Let's pretend that we have an data sheet for an electronics component

              that says we need to decode these 16 bits into

              * a 3-bit operation code,
              * a 6-bit address value,
              * and a 7-bit data value.

              It's really easy to just pattern-match like this, and you're done.
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              # Elixir ðŸ’œ Embedded
              *Binary* pattern-matching
              ``` elixir
              def decode(<<0::2, op::1, addr::9, data::4>>), do: # ...
              def decode(<<      op::3, addr::6, data::7>>), do: # ...

              # ...

              decode(<<0b00010101, 0b01010011>>) # => {0, 341, 3}
              decode(<<0b01010101, 0b01010011>>) # => {2, 42, 83}
              ```

              Notes:

              But oh, by the way, the data sheet also says that

              if the first two bits are zeros, then you're in "extended address" mode,

              so you should interpret the rest of the data as:

              * a 1-bit operation code,
              * a 9-bit address value,
              * and a 4-bit data value.

              No problem, just add another function head.

              This example is obviously contrived, but it's so nice to be able

              to do this instead of procedural bitwise operations.
            </textarea>
          </section>

        </section>

        <!-- Nerves -->

        <section>
          <section data-markdown class="nav">
            <textarea data-template>
              ![Nerves Logo](img/nerves_sticker.png) <!-- .element: class="plain" style="height: 6em" -->

              Craft and deploy

              bulletproof embedded software

              in Elixir

              Notes:

              But I don't recommend you do that, because that's what Nerves is for.
            </textarea>
          </section>

          <section data-background-image="img/elixir_logo_on_pi.jpg">
            <aside class="notes" data-markdown>
              We basically just put Elixir on a Raspberry Pi.

              So... there you go!
            </aside>
          </section>

          <section data-background-image="img/nerves_vs_linux.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              Nerves uses Buildroot to cross-compile a minimal Linux kernel and userland for you.

              It's much smaller than a normal Linux installation because

              it doesn't include all the drivers and tools you don't need to run your app.

              In fact, we replace the init process with a small program called erlinit,

              whose job is just to start the BEAM and run your app.
            </aside>
          </section>

          <section data-background-image="img/nerves_system.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              The Nerves team packages these up into what we call "systems" that

              are specific to a given hardware target, like a Raspberry Pi Zero.

              The systems we provide are really minimal,

              but you can make your own if you need to.

              We have pretty good documentation about how to do that.
            </aside>
          </section>

          <section data-background-image="img/nerves_firmware.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              When you build a Nerves "firmware," it adds your application code to

              the pre-compiled system.

              Your application is responsible for running any OS processes you need,

              for example, using an Elixir Port.

              This firmware runs from a read-only file-system on the device.

              This helps prevent file system corruption when power is suddenly

              removed from an embedded device while it's writing data, and also

              give some peace of mind that the firmware you put on the device is

              going to stay in a consistent state.

              A Nerves firmware, including your application,

              can be as small as 25 MB and boots in about 5 seconds.
            </aside>
          </section>

          <section data-background-image="img/nerves_appdata.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              Of course, we also have a writable partition that you can use to

              persist your data in a place that won't corrupt your boot partition.
            </aside>
          </section>

          <section data-background-image="img/nerves_b_firmware.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              We also have a secondary "firmware slot" that you can use for

              pushing updates to a running device without having to

              re-program its SD card.
            </aside>
          </section>

          <section data-markdown>
            <textarea data-template>
              # Nerves Platform
              App-level fault-tolerance with *Shoehorn*
              > Get your boot on!

              * Configure network
              * Start management tooling
              * Format storage partitions
              * ... Then start your app

              Notes:

              We also have Bootloader, which can be used to ensure the device

              comes up to a known-working state before trying to start your

              application.

              This allows for some limited remote diagnostics or firmware update,

              even if your application fails to start for some reason.
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              # Nerves Platform
              App-level fault-tolerance with *Shoehorn*

              > *Shoehorn* used to be called *Bootloader*.
              > That was confusing because it's not actually a bootloader.
            </textarea>
          </section>

          <section data-markdown class="img-grid">
            <textarea data-template>
              # Support for *Lots of Targets*
              ![rpi0](img/rpi0.png) <!-- .element: class="plain" -->
              ![rpi1](img/rpi1.png) <!-- .element: class="plain" -->
              ![rpi2](img/rpi2.png) <!-- .element: class="plain" -->
              ![rpi3](img/rpi3.png) <!-- .element: class="plain" -->
              ![bbb](img/bbb.png) <!-- .element: class="plain" -->
              ![ev3](img/ev3.png) <!-- .element: class="plain" -->

              Notes:

              Nerves currently supports a bunch of popular and readily-available

              target hardware, like the Raspberry Pi and Beaglebone families,

              and the Lego EV3, which is really neat.
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              # Nerves ðŸ’œ Elixir

              ```bash
              $ mix nerves.new    # Generate a Project
              $ mix deps.get      # Download Pre-Compiled Infrastructure
              $ mix firmware      # Cross-Compile your Project
              $ mix firmware.burn # Burn your SD card
              # ... or ...
              $ mix firmware.push # Update your Firmware over the Network
              ```
            </textarea>
          </section>

          <section data-background-image="img/all_in_one_nerves.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              Nerves gives you the tools you need to build, for example,

              an all-in-one touch-screen kiosk that connects to hardware devices

              and back to a central server, mostly using technologies you already know.
            </aside>
          </section>

          <section data-background-image="img/all_in_one_dev.png" data-background-size="contain">
            <aside class="notes" data-markdown>
              ... and you can use mocks of the hardware in dev and test environments

              so that you don't need to have real hardware available.
            </aside>
          </section>

        </section>

        <!-- Phoenix for Embedded -->

        <section>

          <section data-markdown class="nav">
            <textarea data-template>
              # Phoenix ðŸ’œ "IoT"
              ![Tons of cats](img/cats.png) <!-- .element: class="plain" style="height: 12em" -->

              Notes:

              Next, let's talk about Phoenix.

              This is your server on IoT.
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              Avoid hard CS problems if you can

              ![The Road to 2M Websocket Connections](img/the_road_to_2m_websockets.png) <!-- .element: class="plain" style="height: 10em" -->
              <br/>
              [Gary Rennie - The Road to 2 Million Websocket Connections in Phoenix](https://youtu.be/c6JcVwbOGXc) <!-- .element: class="attribution" -->

              Notes:

              It turns out that Phoenix is pretty good at handling that

              without much special tuning or architecture.

              In this presentation, Gary describes how they were able to get a

              single server to host 2M websocket connections.

              That wasn't the limit of what's possible,

              it was more of an arbitrary point at which they ran out of time

              and motivation to keep going with the test.
            </textarea>
          </section>

          <section>
            <h1>Use all your <em>Cores</em></h1>

            <div style="float: left">
              <p>4 Cores</p>
              <img src="img/rpi3.png" class="plain" style="width: 500px" />
            </div>
            <div style="float: right">
              <p>96 Cores / 192 Threads</p>
              <img src="img/r930.png" class="plain" style="width: 500px" />
            </div>

            <aside class="notes" data-markdown>
              Phoenix does a great job of using all your cores

              (fragment) Whether it's 4 cores in your Raspberry Pi

              (fragment) or tons of cores in your beefy server hardware
            </aside>
          </section>

          <section data-markdown>
            <textarea data-template>
              # Pretty secure by default
              ![Phoenix Security](img/phoenix_security.png) <!-- .element: class="plain" style="height: 10em" -->
              [Griffin Byatt - Plugging the Security Holes in Your Phoenix Application](https://youtu.be/w3lKmFsmlvQ) <!-- .element: class="attribution" -->

              Notes:

              Phoenix is also pretty secure by default.

              In this presentation, Griffin presented his findings from

              analyzing a lot of Phoenix-based web applications in the wild.

              My main take-away from his presentation was that,

              unless you're doing something unusual,

              Phoenix has your back and does the right thing by default.
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              # Embedded web server
              (configuration, HMI, API)

              ![Process Controls](img/process_controls.png) <!-- .element: class="plain" style="height: 11em" -->

              Notes:

              Phoenix also makes a great embedded web server, whether you need

              a configuration page, a human-machine interface, or just a JSON API.
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              # Phoenix Channels
              ![Channels](img/channels.png) <!-- .element: class="plain" style="height: 12em" -->

              Notes:

              Phoenix Channels also offer a great way to easily connect your devices

              to a server, whether it's an app running in a browser or

              a headless sensor device in the field.
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              # GraphQL Subscriptions

              ![Live APIs with GraphQL Subscriptions - Bruce Williams and Ben Wilson](img/graphql_subscriptions.png) <!-- .element: class="plain" style="height: 10em" -->
              <br/>
              [Live APIs with GraphQL Subscriptions - Bruce Williams and Ben Wilson](https://youtu.be/PEckzwggd78) <!-- .element: class="attribution" -->

              Notes:

              I'm also really interested the GraphQL Subscriptions

              feature that Bruce and Ben demoed at ElixirConf this year,

              but I haven't had a chance to try it yet.
            </textarea>
          </section>

        </section>

        <!-- Quick Win -->

        <section>

          <section data-background-image="img/quick_win.jpg" data-background-size="contain">
          </section>

          <section data-background-image="img/gadget_power.png" data-background-size="contain">
          </section>

          <section data-background-image="img/gadget_composite.png" data-background-size="contain">
          </section>

        </section>

        <!-- Wrap Up -->

        <section data-markdown class="nav">
          <textarea data-template>
            ## Have Fun with Nerves! ðŸ’œ
            ![GregMefford](img/GregMefford.jpg) <!-- .element: class="plain" style="height: 6em" -->
            ![GregMefford](img/nerves_logo.png) <!-- .element: class="plain" style="height: 6em" -->

            Greg Mefford (@ferggo)
          </textarea>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,
        controls: false,
        progress: false,
        transition: "fade",
        width: 1024,
        height: 768,
        center: false,
        pdfMaxPagesPerSlide: 1,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });

      for (var slide of document.getElementsByTagName('section')){
        if (slide.getAttribute('data-markdown') == "") {
          slide.setAttribute('data-separator-notes', '^Notes:');
        }

        if (!(slide.getAttribute('data-background') ||
              slide.getAttribute('data-background-image') ||
              slide.getAttribute('data-background-video') ||
              slide.getAttribute('data-background-iframe'))){
          slide.setAttribute('data-background-image', 'img/circuit.svg');
          slide.setAttribute('data-background-color', '#DFDBE5');
          slide.setAttribute('data-background-size', '200px');
          slide.setAttribute('data-background-repeat', 'repeat');
        }
      }
    </script>
  </body>
</html>
